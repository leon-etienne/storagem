# pip install numpy pandas tqdm pillow
"""
Find representative artworks for shelves.
This script reads embeddings from cache (generated by generate_embeddings.py)
and CSV data to find representatives or outliers by shelf.
Supports both CSV output and HTML output with embedded images.
"""
import base64
import pickle
from io import BytesIO
from pathlib import Path
from typing import Dict, Optional

import numpy as np
import pandas as pd
from PIL import Image
from tqdm import tqdm


# ========== EMBEDDING CACHE FUNCTIONS ==========

def get_cache_dir() -> Path:
    """Get the cache directory for embeddings."""
    cache_dir = Path("embeddings_cache")
    cache_dir.mkdir(exist_ok=True)
    return cache_dir


def get_embeddings_cache_file() -> Path:
    """Get the path to the global embeddings cache file."""
    cache_dir = get_cache_dir()
    return cache_dir / "all_embeddings.pkl"


def load_all_embeddings() -> Dict:
    """
    Load all artwork embeddings from cache.
    
    Returns:
        Dictionary mapping artwork ID to embedding vector
    
    Raises:
        FileNotFoundError: If cache file doesn't exist
        Exception: If cache file cannot be loaded
    """
    cache_file = get_embeddings_cache_file()
    
    if not cache_file.exists():
        raise FileNotFoundError(
            f"Embeddings cache not found at {cache_file}. "
            f"Please run generate_embeddings.py first to generate the cache."
        )
    
    try:
        with open(cache_file, "rb") as f:
            cache_data = pickle.load(f)
        
        embeddings_dict = cache_data.get("embeddings", {})
        num_embeddings = cache_data.get("num_embeddings", len(embeddings_dict))
        
        print(f"✓ Loaded {num_embeddings} embeddings from cache")
        return embeddings_dict
    except Exception as e:
        raise Exception(f"Error loading embeddings cache: {e}")


# ========== END EMBEDDING CACHE FUNCTIONS ==========


# ========== IMAGE UTILITY FUNCTIONS ==========

def load_image(image_path: str, base_dir: str = "production-export-2025-11-04t14-27-00-000z") -> Optional[Image.Image]:
    """Load image from thumbnail path. Handles relative paths from CSV."""
    if pd.isna(image_path) or not image_path or image_path == "N/A":
        return None
    
    # Paths from CSV are relative like: production-export-2025-11-04t14-27-00-000z/images/filename.jpg
    # Try using the path directly first
    full_path = Path(image_path)
    if full_path.exists() and full_path.is_file():
        try:
            return Image.open(full_path).convert("RGB")
        except Exception as e:
            pass
    
    # If direct path doesn't work, try extracting filename and looking in base_dir/images
    # Handle paths like "production-export-2025-11-04t14-27-00-000z/images/filename.jpg"
    if "images/" in image_path:
        filename = image_path.split("images/")[-1]
    elif image_path.startswith("/thumbnails/"):
        filename = image_path.replace("/thumbnails/", "")
    else:
        filename = image_path
    
    # Try in base_dir/images
    images_dir = Path(base_dir) / "images"
    if images_dir.exists():
        full_path = images_dir / filename
        if full_path.exists():
            try:
                return Image.open(full_path).convert("RGB")
            except Exception as e:
                pass
    
    return None


def image_to_base64(image: Image.Image, max_size: int = 300) -> str:
    """Convert PIL Image to base64 string, with optional resizing."""
    if image is None:
        return ""
    
    try:
        # Resize if too large (keep aspect ratio)
        if max(image.size) > max_size:
            image.thumbnail((max_size, max_size), Image.Resampling.LANCZOS)
        
        # Convert to RGB if needed
        if image.mode != "RGB":
            image = image.convert("RGB")
        
        # Save to bytes
        buffer = BytesIO()
        image.save(buffer, format="JPEG", quality=85)
        img_bytes = buffer.getvalue()
        
        # Encode to base64
        img_base64 = base64.b64encode(img_bytes).decode("utf-8")
        return f"data:image/jpeg;base64,{img_base64}"
    except Exception as e:
        print(f"Error encoding image to base64: {e}")
        return ""


# ========== END IMAGE UTILITY FUNCTIONS ==========


def find_shelf_representatives(
    csv_path: str,
    base_dir: str = "production-export-2025-11-04t14-27-00-000z",
    batch_size: int = 32,
    top_k: int = 5,
    include_base64: bool = False
) -> pd.DataFrame:
    """
    Find the top K most representative artworks for each shelf (closest to centroid).
    Returns a DataFrame with shelf_no, index, id, title, artist, artwork_no, 
    rank, num_artworks_in_shelf, and distance_to_centroid.
    
    Args:
        csv_path: Path to CSV file
        base_dir: Base directory for images
        batch_size: Unused (kept for compatibility)
        top_k: Number of top representatives to return (default: 5)
        include_base64: If True, include base64-encoded thumbnails in results
    """
    print(f"Loading CSV: {csv_path}")
    df = pd.read_csv(csv_path)
    print(f"Loaded {len(df)} artworks")
    
    # Filter to artworks with shelf information
    if "shelfNo" not in df.columns:
        print("ERROR: 'shelfNo' column not found in CSV")
        return pd.DataFrame()
    
    df = df[df["shelfNo"].notna()].copy()
    df = df[df["shelfNo"] != ""].copy()  # Remove empty shelf numbers
    print(f"Artworks with shelf info: {len(df)}")
    
    # Handle multiple shelf numbers per artwork (split by semicolon or comma)
    # This duplicates the logic from read_data_ting.py to ensure proper splitting
    def parse_shelf_numbers(shelf_value):
        """Parse shelfNo value and return list of individual shelf numbers."""
        if pd.isna(shelf_value) or shelf_value is None:
            return []
        shelf_str = str(shelf_value).strip()
        if not shelf_str:
            return []
        # Split by semicolon or comma
        shelf_numbers = []
        for part in shelf_str.replace(",", ";").split(";"):
            part = part.strip()
            if part:
                try:
                    normalized = str(int(part))  # Remove leading zeros
                    shelf_numbers.append(normalized)
                except ValueError:
                    shelf_numbers.append(part)
        return shelf_numbers
    
    # Parse shelf numbers and explode to create one row per shelf
    df["shelf_list"] = df["shelfNo"].apply(parse_shelf_numbers)
    df = df[df["shelf_list"].apply(len) > 0].copy()  # Remove rows with no shelf numbers
    df = df.explode("shelf_list", ignore_index=True)
    df["shelfNo"] = df["shelf_list"].astype(str)
    df = df.drop(columns=["shelf_list"])
    print(f"After splitting multiple shelf numbers: {len(df)} artworks")
    
    # Load embeddings from cache
    print("Loading embeddings from cache...")
    cached_embeddings = load_all_embeddings()
    
    # Match embeddings to artworks
    embeddings_list = []
    valid_indices = []
    
    for idx, row in tqdm(df.iterrows(), total=len(df), desc="Matching embeddings"):
        # Get artwork ID - try to keep as int if possible
        raw_id = row.get("id", idx)
        try:
            artwork_id = int(float(raw_id)) if pd.notna(raw_id) else idx
        except (ValueError, TypeError):
            artwork_id = raw_id if pd.notna(raw_id) else idx
        
        # Try to find embedding (check both int and str versions)
        emb = None
        if artwork_id in cached_embeddings:
            emb = cached_embeddings[artwork_id]
        elif str(artwork_id) in cached_embeddings:
            emb = cached_embeddings[str(artwork_id)]
        
        if emb is not None:
            embeddings_list.append(emb)
            valid_indices.append(idx)
        else:
            print(f"Warning: No embedding found for artwork ID {artwork_id} at index {idx}")
    
    if not embeddings_list:
        print("ERROR: No embeddings found for any artworks")
        return pd.DataFrame()
    
    embeddings = np.array(embeddings_list, dtype=np.float32)
    df_valid = df.loc[valid_indices].copy()
    print(f"Matched {len(embeddings)} embeddings to artworks")
    
    # Group by shelf and find representative for each
    print("Finding shelf representatives...")
    results = []
    
    unique_shelves = sorted(df_valid["shelfNo"].unique(), key=lambda x: str(x))
    for shelf_no in tqdm(unique_shelves, desc="Processing shelves"):
        shelf_mask = df_valid["shelfNo"] == shelf_no
        shelf_df = df_valid[shelf_mask].copy()
        shelf_embeddings = embeddings[shelf_mask]
        
        if len(shelf_embeddings) == 0:
            continue
        
        # Calculate centroid (average embedding) of the shelf
        centroid = np.mean(shelf_embeddings, axis=0)
        centroid = centroid / np.linalg.norm(centroid)  # Normalize
        
        # Find distances to centroid for all artworks on this shelf
        distances = np.linalg.norm(shelf_embeddings - centroid, axis=1)
        
        # Get top K closest artworks (sorted by distance)
        k = min(top_k, len(distances))
        top_indices = np.argsort(distances)[:k]
        
        # Add top K artworks to results
        for rank, idx in enumerate(top_indices, 1):
            artwork = shelf_df.iloc[idx]
            
            # Get the id column value from CSV (not row index)
            csv_id = artwork.get("id", "N/A")
            
            title = artwork.get("title", "Unknown")
            artist = artwork.get("artist", "Unknown")
            artwork_no = artwork.get("artworkNo", artwork.get("id", "N/A"))
            artwork_id = artwork.get("_id", artwork.get("id", "N/A"))
            cluster = artwork.get("cluster", "N/A")
            # Read thumbnail path directly from CSV (already set by read_data_ting.py)
            thumbnail_path = artwork.get("thumbnail", "N/A")
            
            # Load and encode image if requested
            thumbnail = thumbnail_path
            if include_base64:
                image = load_image(thumbnail_path, base_dir) if thumbnail_path and pd.notna(thumbnail_path) and thumbnail_path != "N/A" else None
                thumbnail = image_to_base64(image) if image else ""
            
            result = {
                "shelf_no": shelf_no,
                "rank": rank,
                "index": csv_id,
                "title": title,
                "artist": artist,
                "cluster": cluster,
                "num_artworks_in_shelf": len(shelf_df),
                "distance_to_centroid": float(distances[idx]),
                "thumbnail": thumbnail
            }
            
            # Add optional fields
            if not include_base64:
                result["id"] = artwork_id
                result["artwork_no"] = artwork_no
            
            results.append(result)
    
    # Create DataFrame and reorder columns
    results_df = pd.DataFrame(results)
    if not results_df.empty and include_base64:
        # Reorder columns for print mode
        column_order = ["shelf_no", "rank", "index", "title", "artist", "cluster", 
                       "num_artworks_in_shelf", "distance_to_centroid", "thumbnail"]
        available_columns = [col for col in column_order if col in results_df.columns]
        results_df = results_df[available_columns]
    
    return results_df


def find_shelf_outliers(
    csv_path: str,
    base_dir: str = "production-export-2025-11-04t14-27-00-000z",
    batch_size: int = 32,
    top_k: int = 5,
    include_base64: bool = False
) -> pd.DataFrame:
    """
    Find the top K outlier artworks for each shelf (furthest from centroid).
    Returns a DataFrame with shelf_no, index, id, title, artist, artwork_no, 
    cluster, rank, num_artworks_in_shelf, and distance_to_centroid.
    
    Args:
        csv_path: Path to CSV file
        base_dir: Base directory for images
        batch_size: Unused (kept for compatibility)
        top_k: Number of top outliers to return (default: 5)
        include_base64: If True, include base64-encoded thumbnails in results
    """
    print(f"Loading CSV: {csv_path}")
    df = pd.read_csv(csv_path)
    print(f"Loaded {len(df)} artworks")
    
    # Filter to artworks with shelf information
    if "shelfNo" not in df.columns:
        print("ERROR: 'shelfNo' column not found in CSV")
        return pd.DataFrame()
    
    df = df[df["shelfNo"].notna()].copy()
    print(f"Artworks with shelf info: {len(df)}")
    
    # Handle multiple shelf numbers (split by semicolon or comma)
    # Create a list column for shelf numbers
    if "shelfNo" in df.columns:
        def parse_shelf_list(shelf_value):
            if pd.isna(shelf_value):
                return []
            shelf_str = str(shelf_value).strip()
            if not shelf_str:
                return []
            # Replace commas with semicolons for consistent splitting
            shelf_str = shelf_str.replace(",", ";")
            return [s.strip() for s in shelf_str.split(";") if s.strip()]
        
        df["shelf_list"] = df["shelfNo"].apply(parse_shelf_list)
        
        # Explode to create separate rows for each shelf number
        artworks_no_shelf = df[df["shelf_list"].apply(len) == 0].copy()
        artworks_with_shelf = df[df["shelf_list"].apply(len) > 0].copy()
        
        if len(artworks_with_shelf) > 0:
            artworks_exploded = artworks_with_shelf.explode("shelf_list")
            artworks_exploded["shelfNo"] = artworks_exploded["shelf_list"]
            df = pd.concat([artworks_no_shelf, artworks_exploded], ignore_index=True)
            df = df.drop(columns=["shelf_list"])
    
    print(f"After splitting multiple shelf numbers: {len(df)} artworks")
    
    # Load embeddings from cache
    print("Loading embeddings from cache...")
    cached_embeddings = load_all_embeddings()
    
    # Match embeddings to artworks
    embeddings_list = []
    valid_indices = []
    
    for idx, row in tqdm(df.iterrows(), total=len(df), desc="Matching embeddings"):
        # Get artwork ID - try to keep as int if possible
        raw_id = row.get("id", idx)
        try:
            artwork_id = int(float(raw_id)) if pd.notna(raw_id) else idx
        except (ValueError, TypeError):
            artwork_id = raw_id if pd.notna(raw_id) else idx
        
        # Try to find embedding (check both int and str versions)
        emb = None
        if artwork_id in cached_embeddings:
            emb = cached_embeddings[artwork_id]
        elif str(artwork_id) in cached_embeddings:
            emb = cached_embeddings[str(artwork_id)]
        
        if emb is not None:
            embeddings_list.append(emb)
            valid_indices.append(idx)
        else:
            print(f"Warning: No embedding found for artwork ID {artwork_id} at index {idx}")
    
    if not embeddings_list:
        print("ERROR: No embeddings found for any artworks")
        return pd.DataFrame()
    
    embeddings = np.array(embeddings_list, dtype=np.float32)
    df_valid = df.loc[valid_indices].copy()
    print(f"Matched {len(embeddings)} embeddings to artworks")
    
    # Group by shelf and find outliers for each
    print("Finding shelf outliers...")
    results = []
    
    unique_shelves = sorted(df_valid["shelfNo"].unique(), key=lambda x: str(x))
    for shelf_no in tqdm(unique_shelves, desc="Processing shelves"):
        shelf_mask = df_valid["shelfNo"] == shelf_no
        shelf_df = df_valid[shelf_mask].copy()
        shelf_embeddings = embeddings[shelf_mask]
        
        if len(shelf_embeddings) == 0:
            continue
        
        # Calculate centroid (average embedding) of the shelf
        centroid = np.mean(shelf_embeddings, axis=0)
        centroid = centroid / np.linalg.norm(centroid)  # Normalize
        
        # Find distances to centroid for all artworks on this shelf
        distances = np.linalg.norm(shelf_embeddings - centroid, axis=1)
        
        # Get top K furthest artworks (sorted by distance, descending)
        k = min(top_k, len(distances))
        top_indices = np.argsort(distances)[-k:][::-1]  # Get largest distances first
        
        # Add top K outliers to results
        for rank, idx in enumerate(top_indices, 1):
            artwork = shelf_df.iloc[idx]
            
            # Get the id column value from CSV (not row index)
            csv_id = artwork.get("id", "N/A")
            
            title = artwork.get("title", "Unknown")
            artist = artwork.get("artist", "Unknown")
            artwork_no = artwork.get("artworkNo", artwork.get("id", "N/A"))
            artwork_id = artwork.get("_id", artwork.get("id", "N/A"))
            cluster = artwork.get("cluster", "N/A")
            # Read thumbnail path directly from CSV (already set by read_data_ting.py)
            thumbnail_path = artwork.get("thumbnail", "N/A")
            
            # Load and encode image if requested
            thumbnail = thumbnail_path
            if include_base64:
                image = load_image(thumbnail_path, base_dir) if thumbnail_path and pd.notna(thumbnail_path) and thumbnail_path != "N/A" else None
                thumbnail = image_to_base64(image) if image else ""
            
            result = {
                "shelf_no": shelf_no,
                "rank": rank,
                "index": csv_id,
                "title": title,
                "artist": artist,
                "cluster": cluster,
                "num_artworks_in_shelf": len(shelf_df),
                "distance_to_centroid": float(distances[idx]),
                "thumbnail": thumbnail
            }
            
            # Add optional fields
            if not include_base64:
                result["id"] = artwork_id
                result["artwork_no"] = artwork_no
            
            results.append(result)
    
    # Create DataFrame and reorder columns
    results_df = pd.DataFrame(results)
    if not results_df.empty and include_base64:
        # Reorder columns for print mode
        column_order = ["shelf_no", "rank", "index", "title", "artist", "cluster", 
                       "num_artworks_in_shelf", "distance_to_centroid", "thumbnail"]
        available_columns = [col for col in column_order if col in results_df.columns]
        results_df = results_df[available_columns]
    
    return results_df


def create_html_view(results_df: pd.DataFrame, output_file: str, mode: str = "outlier"):
    """Create an HTML file with embedded images for better viewing."""
    mode_title = "Shelf Representatives" if mode == "representative" else "Shelf Outliers"
    html_content = f"""<!DOCTYPE html>
<html>
<head>
    <title>{mode_title}</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }}
        h1 {{
            color: #333;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }}
        th {{
            background-color: #4CAF50;
            color: white;
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }}
        td {{
            padding: 10px;
            border: 1px solid #ddd;
        }}
        tr:nth-child(even) {{
            background-color: #f2f2f2;
        }}
        .thumbnail {{
            max-width: 150px;
            max-height: 150px;
            object-fit: contain;
        }}
        .shelf-header {{
            background-color: #2196F3;
            color: white;
            font-weight: bold;
            font-size: 1.2em;
            padding: 15px;
            margin-top: 20px;
            page-break-after: avoid;
            orphans: 3;
            widows: 3;
        }}
        .shelf-section {{
            page-break-after: always;
            page-break-inside: avoid;
            orphans: 3;
            widows: 3;
        }}
        @media print {{
            .shelf-section {{
                page-break-after: always;
                page-break-inside: avoid;
                orphans: 3;
                widows: 3;
            }}
            .shelf-header {{
                page-break-after: avoid;
                page-break-before: avoid;
                orphans: 3;
                widows: 3;
            }}
            .shelf-section:first-of-type .shelf-header {{
                page-break-before: auto;
            }}
            table {{
                page-break-inside: auto;
            }}
            tr {{
                page-break-inside: avoid;
            }}
        }}
    </style>
</head>
<body>
    <h1>{mode_title}</h1>
"""
    
    # Group by shelf_no
    for shelf_no in sorted(results_df["shelf_no"].unique(), key=lambda x: str(x)):
        shelf_data = results_df[results_df["shelf_no"] == shelf_no].sort_values("rank")
        
        mode_label = "representatives" if mode == "representative" else "outliers"
        html_content += f'    <div class="shelf-section">\n'
        html_content += f'    <div class="shelf-header">Shelf {shelf_no} ({len(shelf_data)} {mode_label})</div>\n'
        html_content += '    <table>\n'
        html_content += '        <tr>\n'
        html_content += '            <th>Rank</th>\n'
        html_content += '            <th>Index</th>\n'
        html_content += '            <th>Title</th>\n'
        html_content += '            <th>Artist</th>\n'
        html_content += '            <th>Cluster</th>\n'
        html_content += '            <th>Distance</th>\n'
        html_content += '            <th>Thumbnail</th>\n'
        html_content += '        </tr>\n'
        
        for _, row in shelf_data.iterrows():
            thumbnail_img = f'<img src="{row["thumbnail"]}" class="thumbnail" alt="Thumbnail" />' if row.get("thumbnail") and row["thumbnail"] != "N/A" else "No image"
            
            html_content += '        <tr>\n'
            html_content += f'            <td>{row["rank"]}</td>\n'
            html_content += f'            <td>{row["index"]}</td>\n'
            html_content += f'            <td>{row["title"]}</td>\n'
            html_content += f'            <td>{row["artist"]}</td>\n'
            html_content += f'            <td>{row["cluster"]}</td>\n'
            html_content += f'            <td>{row["distance_to_centroid"]:.4f}</td>\n'
            html_content += f'            <td>{thumbnail_img}</td>\n'
            html_content += '        </tr>\n'
        
        html_content += '    </table>\n'
        html_content += '    </div>\n'
    
    html_content += """
</body>
</html>
"""
    
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(html_content)


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Find representative or outlier artworks for shelves.")
    parser.add_argument("--csv", default="artworks_with_thumbnails_ting.csv", help="Path to CSV file")
    parser.add_argument("--base-dir", default="production-export-2025-11-04t14-27-00-000z", help="Base directory for images")
    parser.add_argument("--output", default="shelf_representatives.csv", help="Output CSV file")
    parser.add_argument("--outliers", action="store_true", help="Find outliers instead of representatives")
    parser.add_argument("--top-k", type=int, default=5, help="Number of top results per shelf (default: 5, use 15 for print mode)")
    parser.add_argument("--print-mode", action="store_true", help="Enable print mode: top 15 results with base64 images and HTML output")
    args = parser.parse_args()
    
    # Adjust top_k for print mode
    if args.print_mode:
        args.top_k = 15
    
    # Determine which function to use
    if args.outliers:
        results_df = find_shelf_outliers(
            args.csv, 
            args.base_dir, 
            top_k=args.top_k,
            include_base64=args.print_mode
        )
        mode_name = "outlier"
    else:
        results_df = find_shelf_representatives(
            args.csv, 
            args.base_dir, 
            top_k=args.top_k,
            include_base64=args.print_mode
        )
        mode_name = "representative"
    
    if not results_df.empty:
        # Save to CSV
        results_df.to_csv(args.output, index=False)
        num_shelves = len(results_df["shelf_no"].unique())
        num_results = len(results_df)
        print(f"\n✓ Processed {num_shelves} shelves")
        print(f"✓ Found {num_results} {mode_name} artworks (top {args.top_k} per shelf)")
        print(f"✓ Results saved to {args.output}")
        
        # Create HTML view if in print mode
        if args.print_mode:
            html_output = args.output.replace(".csv", ".html")
            create_html_view(results_df, html_output, mode_name)
            print(f"✓ HTML view saved to {html_output}")
    else:
        print("No results to display")


if __name__ == "__main__":
    main()

